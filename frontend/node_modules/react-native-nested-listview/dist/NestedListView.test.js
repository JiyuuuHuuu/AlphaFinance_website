var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as React from 'react';
import { Pressable, Text, View } from 'react-native';
import NestedListView, { NestedRow } from '.';
import { render, waitFor, fireEvent } from '@testing-library/react-native';
let mockCounter = 0;
jest.mock('shortid', () => ({
    generate: () => `${mockCounter++}`,
}));
const renderNode = (node) => (<View>
    <Text>{node.title}</Text>
  </View>);
describe('NestedListView', () => {
    test('renders with simple array', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            { title: 'child1' },
            { title: 'child2' },
            { title: 'child3' },
        ];
        const { queryByText } = render(<NestedListView getChildrenName={() => 'items'} renderNode={(node) => (<View>
            <Text>{node.title}</Text>
          </View>)} data={data}/>);
        yield waitFor(() => {
            [1, 2, 3].forEach((item) => {
                const component = queryByText(`child${item}`);
                expect(component).toBeDefined();
            });
        });
    }));
    test('renders with nested arrays', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            {
                title: 'child1',
                items: [{ name: 'subchild 1.1' }, { name: 'subchild 1.2' }],
            },
            { title: 'child2', items: [{ key: 'subchild 2.1' }] },
            { title: 'child3' },
        ];
        const { queryByText } = render(<NestedListView getChildrenName={() => 'items'} renderNode={(node) => {
            var _a;
            return (<View>
            <Text>{(_a = node.title) !== null && _a !== void 0 ? _a : node.name}</Text>
          </View>);
        }} data={data}/>);
        yield waitFor(() => {
            const parent = queryByText('child1');
            if (parent) {
                fireEvent.press(parent);
            }
            const component1 = queryByText('subchild 1.1');
            expect(component1).toBeDefined();
            const component2 = queryByText('subchild 1.2');
            expect(component2).toBeDefined();
        });
    }));
    test('renders with nested arrays open and close', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            {
                title: 'child1',
                items: [{ name: 'subchild 1.1' }, { name: 'subchild 1.2' }],
            },
            { title: 'child2', items: [{ key: 'subchild 2.1' }] },
            { title: 'child3' },
        ];
        const { queryByText } = render(<NestedListView getChildrenName={() => 'items'} renderNode={(node) => {
            var _a;
            return (<View>
            <Text>{(_a = node.title) !== null && _a !== void 0 ? _a : node.name}</Text>
          </View>);
        }} data={data}/>);
        yield waitFor(() => {
            const parent = queryByText('child1');
            expect(queryByText('subchild 1.1')).toBeDefined();
            if (parent) {
                fireEvent.press(parent);
            }
            expect(queryByText('subchild 1.1')).toBeDefined();
        });
    }));
    test('renders with nested arrays and children with different name', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            {
                title: 'child1',
                items: [{ name: 'subchild 1.1' }, { name: 'subchild 1.2' }],
            },
            { title: 'child2', descendants: [{ key: 'subchild 2.1' }] },
            { title: 'child3' },
        ];
        const { queryByText } = render(<NestedListView getChildrenName={(node) => {
            if (node.title === 'child2') {
                return 'descendants';
            }
            return 'items';
        }} renderNode={(node) => (<View>
            <Text>{node.title}</Text>
          </View>)} data={data}/>);
        yield waitFor(() => {
            const parent = queryByText('child2');
            if (parent) {
                fireEvent.press(parent);
            }
            const children = parent === null || parent === void 0 ? void 0 : parent.children;
            expect(children === null || children === void 0 ? void 0 : children.length).toEqual(1);
        });
    }));
    test('renders with nested arrays and children with different name that does not exists', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            {
                title: 'child1',
                items: [{ name: 'subchild 1.1' }, { name: 'subchild 1.2' }],
            },
            {
                title: 'child2',
                descendants: [{ key: 'subchild 2.1', title: 'subchild 2.1' }],
            },
            { title: 'child3' },
        ];
        const { queryByText } = render(<NestedListView getChildrenName={(node) => {
            if (node.title === 'child2') {
                return 'children';
            }
            return 'items';
        }} renderNode={(node) => (<View>
            <Text>{node.title}</Text>
          </View>)} data={data}/>);
        let parent;
        yield waitFor(() => {
            parent = queryByText('child2');
            fireEvent.press(parent);
            const child = queryByText('subchild 2.1');
            expect(child).toBeNull();
        });
    }));
    test('renders with children as objects', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            {
                name: 'Main Parent',
                children: {
                    child1: {
                        name: 'Main Child 1',
                        children: {
                            child1: {
                                name: 'Sub Child 1',
                                children: {},
                            },
                            child2: {
                                name: 'Sub Child 2',
                                children: {
                                    subChild1: {
                                        name: 'Sample',
                                        children: {},
                                    },
                                },
                            },
                        },
                    },
                    child2: {
                        name: 'Main Child 2',
                        children: {
                            child1: {
                                name: 'Sub Child 1',
                                children: {},
                            },
                            child2: {
                                name: 'Sub Child 2',
                                children: {},
                            },
                        },
                    },
                },
            },
        ];
        const { queryByText } = render(<NestedListView getChildrenName={() => 'children'} renderNode={(node) => (<View>
            <Text>{node.name}</Text>
          </View>)} data={data}/>);
        yield waitFor(() => {
            const parent = queryByText('Main Parent');
            if (parent) {
                fireEvent.press(parent);
            }
            const firstChild = queryByText('Main Child 1');
            expect(firstChild).toBeDefined();
            if (firstChild) {
                fireEvent.press(firstChild);
            }
            const secondChild = queryByText('Sub Child 2');
            expect(secondChild).toBeDefined();
        });
    }));
    test('onNodePressed should be called when press a node', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            { title: 'child1' },
            { title: 'child2' },
            { title: 'child3' },
        ];
        const mockOnNodePressed = jest.fn();
        const { queryByText } = render(<NestedListView onNodePressed={mockOnNodePressed} renderNode={(node) => (<View>
            <Text>{node.title}</Text>
          </View>)} data={data}/>);
        const component = queryByText('child1');
        expect(component).toBeDefined();
        if (component) {
            fireEvent.press(component);
        }
        expect(mockOnNodePressed).toBeCalledTimes(1);
    }));
    test('renders with NestedRow', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            { title: 'child1' },
            { title: 'child2' },
            { title: 'child3' },
        ];
        const mockOnNodePressed = jest.fn();
        const { UNSAFE_queryAllByType } = render(<NestedListView onNodePressed={mockOnNodePressed} renderNode={(node, level) => (<NestedRow level={level}>{node.name}</NestedRow>)} data={data}/>);
        const component = UNSAFE_queryAllByType(NestedRow);
        expect(component.length).toEqual(3);
    }));
    test('renders without renderNode', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            { title: 'child1' },
            { title: 'child2' },
            { title: 'child3' },
        ];
        const { queryByText } = render(<NestedListView 
        // @ts-ignore
        renderNode={null} data={data}/>);
        const component = queryByText('prop renderNode has not been passed');
        expect(component).toBeDefined();
    }));
    test('renders without data', () => __awaiter(void 0, void 0, void 0, function* () {
        const { queryByText } = render(<NestedListView renderNode={renderNode} 
        // @ts-ignore
        data={null}/>);
        const component = queryByText('prop data has not been passed');
        expect(component).toBeDefined();
    }));
    test('renders with isLast renderNode', () => __awaiter(void 0, void 0, void 0, function* () {
        const data = [
            {
                title: 'child1',
                items: [{ title: 'subchild 1.1' }, { title: 'subchild 1.2' }],
            },
        ];
        const mockIsTheLast = jest.fn();
        const { UNSAFE_getByType } = render(<NestedListView renderNode={(item, level, isLastItem) => {
            mockIsTheLast(isLastItem);
            return <NestedRow level={level}>{item.title}</NestedRow>;
        }} data={data}/>);
        yield waitFor(() => {
            const child1 = UNSAFE_getByType(Pressable);
            if (child1) {
                fireEvent.press(child1);
            }
            expect(mockIsTheLast).toHaveBeenLastCalledWith(true);
        });
    }));
});
//# sourceMappingURL=NestedListView.test.js.map